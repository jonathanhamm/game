####################################################################################################
Lexical Grammar
####################################################################################################
identifer ::= [a-zA-Z][a-zA-Z0-9]*
String
Num
Shader
Texture
Program
Mesh
Model
Instance
<string> ::= "[^\"]*"
<number> ::= \d+(\.\d+)?
(
)
{
}
[
]
,
:
:=
.
+
-
*
/

####################################################################################################
Phrase Structure Grammar
####################################################################################################
Semantic Functions:
	- makeNode(left, parent, right) - create new binary tree node
====================================================================================================

<levelpackage> ::= <header> <body>

<header> ::= <object>

<propertyList> ::= <property> <propertyList'> | E

<propertyList_> ::= "," <property> <propertyList'> | E

<property> ::= string ":" <expression> 

<body> ::= "{" <statementList> "}"

<statementList> ::= <statement> <optSemicolon> <statementList> | E

<optSemicolon> ::= ; | E

<statement> ::= <declaration> | <assignstmt>

<declaration> ::= <type> identifier <optAssign>

<optAssign> ::= ":=" <expression> | E

<type> ::= <basicType> <optArray>

<basicType> ::=
	"Shader" | "Texture" 
	| "Program" | "Mesh" 
	| "Model" | "Instance" 
	| "Num" | "String"
	| "Dict" | "$"

<optArray> ::= [ <optExpression> ] <optArray> | E

<assignstmt> ::= identifier <idsuffix> ":=" <expression>

<optExpression> ::= <expression> | E

<expression> ::= <term> <expression_> 
{
	if <expression_> <> E:
		this.node := makeNode(<expression_>.op, <term>.node, <expression>.<term>.node)
	else:

	fi
}

<expression_> ::= 
	addop <term> [1] <expression_> 
	{
		phase1.[1]:
			_root := makeNode(_root, addop, <term>)
			call <expression_> {
				<expression_>.root := _root
			}
	}
	| 
	E

<sign> ::= "+" | "-"

<term> ::= <factor> <term_>

<term_> ::= mulop <factor> <term_> | E

<factor> ::= 
	<sign> <expression> <idsuffix>
	| identifier <idsuffix> 
	| number | string <idsuffix>
	| "(" <expression> ")" <idsuffix>
	| <object> <idsuffix>
	| <array> <idsuffix>

<idsuffix> ::= 
	"." identifier <idsuffix>
	| "(" <expressionList> ")" <idsuffix>
	| "[" <expression> "]" <idsuffx>
	| E

<expressionList> ::= 
	<expression> <expressionList'> 
	| E

<expressionList_> ::= 
	, <expression> <expressionList'> 
	| E

<object> ::= "{" <propertyList> "}"

<array> ::= "[" <expressionList> "]"

